<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EOSDAC: Documentation log4j style</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EOSDAC
   </div>
   <div id="projectbrief">Open source decentralised DAC platform for EOSIO blockchains</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_node_modules_typescript-logging_docs_latest_log4j.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Documentation log4j style </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page provides an overview of the log4j style of logging and its api. Please note that full API documentation can be found in the docs bundle.</p>
<p><b>Note</b>: _This api is not supported by the browser extension, it may be in a future release, if you care for the browser plugin, please use categorized logging instead (see main page).</p>
<ul>
<li><a href="#usage">Usage</a></li>
<li><a href="#default-loggerfactory">Default LoggerFactory</a></li>
<li><a href="#formatting-message">Formatting message</a></li>
<li><a href="#custom-logger">Custom logger</a></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#api-and-documentation">Api and documentation</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md4415"></a>
Usage</h1>
<p>The example below configures a LoggerFactory and exports it to be used by consumers. Two LogGroupRules are added for two different groups here, service and ui.</p>
<p>Config.ts </p><div class="fragment"><div class="line">import {LoggerFactoryOptions, LogGroupRule, LogLevel, LoggerFactory, LFService} from &quot;typescript-logging&quot;;</div>
<div class="line"> </div>
<div class="line">const options = new LoggerFactoryOptions();</div>
<div class="line">options.addRule(new LogGroupRule(new RegExp(&quot;service.+&quot;), LogLevel.Info));</div>
<div class="line">options.addRule(new LogGroupRule(new RegExp(&quot;ui.+&quot;), LogLevel.Info));</div>
<div class="line"> </div>
<div class="line">export const factory: LoggerFactory = LFService.createNamedLoggerFactory(&quot;example&quot;, options);</div>
</div><!-- fragment --><p>The class below exports an instance of itself, and has a method called createProduct(), which creates a product and logs in the method. Product source is left out for this example.</p>
<p>ProductService.ts </p><div class="fragment"><div class="line">import {factory} from &quot;./Config&quot;;</div>
<div class="line"> </div>
<div class="line">const log = factory.getLogger(&quot;service.Product&quot;);</div>
<div class="line"> </div>
<div class="line">export class ProductService {</div>
<div class="line"> </div>
<div class="line">  createProduct(name: string): Product {</div>
<div class="line">     // Normal log</div>
<div class="line">     log.info(&quot;Creating product with name: &quot; + name);</div>
<div class="line"> </div>
<div class="line">     // Lambda log (cheaper, only called when needed)</div>
<div class="line">     log.info(() =&gt; &quot;Creating product with name: &quot; + name);</div>
<div class="line"> </div>
<div class="line">     return new Product(name);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">export const productService: ProductService = new ProductService();</div>
</div><!-- fragment --><p>The class below pretends to be SomeUI class, which when pretty() is called upon it creates a product and logs that in the ui logger.</p>
<p>SomeUI.ts </p><div class="fragment"><div class="line">import {factory} from &quot;./Config&quot;;</div>
<div class="line">import {productService} from &quot;./ProductService&quot;;</div>
<div class="line"> </div>
<div class="line">const log = factory.getLogger(&quot;ui.SomeUI&quot;);</div>
<div class="line"> </div>
<div class="line">export class SomeUI {</div>
<div class="line"> </div>
<div class="line">  pretty(name: string): void {</div>
<div class="line">     const product = productService.createProduct(name);</div>
<div class="line"> </div>
<div class="line">     log.info(&quot;Pretty ui: &quot; + product.name);</div>
<div class="line"> </div>
<div class="line">     // Lambda log (cheaper, only called when needed)</div>
<div class="line">     log.info(() =&gt; &quot;Pretty ui: &quot; + product.name);</div>
<div class="line"> </div>
<div class="line">     return new Product(name);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>Let's assume someUi.pretty("Beer"); is called, the output would then be something like the following:</p>
<p>Output </p><div class="fragment"><div class="line">2016-12-22 11:14:26,273 INFO [service.Product] Creating product with name: Beer</div>
<div class="line">2016-12-22 11:14:26,274 INFO [service.Product] Creating product with name: Beer</div>
<div class="line">2016-12-22 11:14:26,275 INFO [ui.SomeUI] Pretty ui: Beer</div>
<div class="line">2016-12-22 11:14:26,276 INFO [ui.SomeUI] Pretty ui: Beer</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md4416"></a>
Default LoggerFactory</h1>
<p>The library provides a default LoggerFactory. This factory is available as: LFService.DEFAULT This is the standard factory available and can be used to get Loggers from as well.</p>
<p>The usage of the <b>default LoggerFactory is recommended for library/framework developers</b>. By using it, end users can easily enable logging for these frameworks in addition to their own application logging when using log4j. By default logging is configured to log on Error level.</p>
<p>Make sure to specify unique Logger names to identify your framework/library.</p>
<p>```typescript const logger = LFService.DEFAULT.getLogger("reactjs/components"); ````</p>
<h1><a class="anchor" id="autotoc_md4417"></a>
Formatting message</h1>
<p>If you do not need a custom logger but need a custom message for the other logger types (non-custom), you can specify a custom formatterLogMessage lambda instead. This allows you to change the log message without the need to implement a custom logger.</p>
<p>The following code gives an example on how to do this (imports have been left out): </p><div class="fragment"><div class="line">const options = new LoggerFactoryOptions();</div>
<div class="line">const rule = new LogGroupRule(new RegExp(&quot;.+&quot;), LogLevel.Info);</div>
<div class="line">// Message only</div>
<div class="line">rule.formatterLogMessage = (message) =&gt; message.message;</div>
<div class="line">options.addLogGroupRule(rule);</div>
<div class="line"> </div>
<div class="line">const factory = LFService.createNamedLoggerFactory(&quot;world&quot;, options);</div>
<div class="line">// This logger will use the custom formatted message now</div>
<div class="line">const logger = factory.getLogger(&quot;MyLogger&quot;);</div>
</div><!-- fragment --><p>The logger from the example above will now use the given custom formatterLogMessage, and will only log the message without any additional information such as time.</p>
<h1><a class="anchor" id="autotoc_md4418"></a>
Custom logger</h1>
<p>By default logging will go the console. In some cases you may want to use a custom logger which either logs differently or logs elsewhere. The example below shows how to do add a custom logger.</p>
<p>CustomLogger.ts </p><div class="fragment"><div class="line">  // Custom logger, extend AbstractLogger which makes your life easy.</div>
<div class="line">export class CustomLogger extends AbstractLogger {</div>
<div class="line"> </div>
<div class="line">    constructor(name: string, settings: LogGroupRuntimeSettings) {</div>
<div class="line">      super(name, settings);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    protected doLog(msg: LogMessage): void {</div>
<div class="line">      // Do what you need to do with this log message!</div>
<div class="line">      // You can use this.createDefaultLogMessage(msg) to get a fully default formatted message if you want.</div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --><p>The example above extends AbstractLogger, if you want to do everything yourself you can implement the Logger interface instead - however that is a lot of work.</p>
<p>Config.ts </p><div class="fragment"><div class="line">// The options, define LoggerType.Custom, then use a closure to return the new logger</div>
<div class="line">// (this will be called by the library when it creates a new logger).</div>
<div class="line">// Make sure to return a new instance always, unless they are shareable between different loggers.</div>
<div class="line">const loggerOptions = new LoggerFactoryOptions()</div>
<div class="line">  .addLogGroupRule(new LogGroupRule(new RegExp(&quot;.+&quot;),LogLevel.Info, new LogFormat(), LoggerType.Custom,</div>
<div class="line">    (name: string, logGroupRule: LogGroupRule) =&gt; new CustomLogger(name, logGroupRule)</div>
<div class="line">));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">export const loggerFactory = LFService.createNamedLoggerFactory(&quot;example&quot;, options);</div>
<div class="line"> </div>
<div class="line">// usage, where-ever.</div>
<div class="line">const logger = loggerFactory.getLogger(&quot;SomeName&quot;);  // This will return your logger now.</div>
</div><!-- fragment --><p>The config defines new options, with LoggerType.Custom and a lambda which returns the new CustomLogger.</p>
<h1><a class="anchor" id="autotoc_md4419"></a>
Examples</h1>
<p>Below follow some examples on how to use the log4j style of logging.</p>
<p><b>Importing</b> </p><div class="fragment"><div class="line">import {LFService,LoggerFactoryOptions} from &quot;typescript-logging&quot;</div>
</div><!-- fragment --><p>All classes can be imported from "typescript-logging".</p>
<p><b>Create default LoggerFactory with default options and log message</b> </p><div class="fragment"><div class="line">const factory = LFService.createLoggerFactory();</div>
<div class="line">const logger = factory.getLogger(&quot;SomeName&quot;);</div>
<div class="line">logger.info(&quot;Will log on info and higher by default&quot;);</div>
</div><!-- fragment --><p><b>Create named LoggerFactory with default options and log messages using LogData</b> </p><div class="fragment"><div class="line">const factory = LFService.createNamedLoggerFactory(&quot;MyNamedFactory&quot;);</div>
<div class="line">const logger = factory.getLogger(&quot;SomeName&quot;);</div>
<div class="line"> </div>
<div class="line">// No additional data, just message.</div>
<div class="line">logger.info({msg: &quot;Will log on info and higher by default&quot;});</div>
<div class="line"> </div>
<div class="line">// Additional data is formatted using JSON.stringify(..) by default</div>
<div class="line">const secretData = {secret: true, user: &quot;secret&quot;};</div>
<div class="line">logger.info({msg: &quot;a&quot;, data: secretData});</div>
<div class="line"> </div>
<div class="line">// Additional data is formatted according custom lambda, can be inlined too etc.</div>
<div class="line">const formatter = (data: any) =&gt; &quot;special stuff here: &quot; + JSON.stringify(data)&quot;;</div>
<div class="line">logger.info({msg: &quot;hello!&quot;, data: secretData, ds: formatter});</div>
</div><!-- fragment --><p><b>Create LoggerFactory, which logs on DEBUG (and higher) for all loggers.</b> </p><div class="fragment"><div class="line">const factory = LFService.createNamedLoggerFactory(&quot;example&quot;, new LoggerFactoryOptions()</div>
<div class="line">  .addLogGroupRule(new LogGroupRule(new RegExp(&quot;.+&quot;), LogLevel.Debug)));</div>
<div class="line">const logger = factory.getLogger(&quot;AnyName&quot;);</div>
<div class="line">logger.trace(&quot;Will not be logged&quot;);</div>
<div class="line">logger.debug(&quot;Will log&quot;);</div>
<div class="line">logger.info(&quot;Will log&quot;); // etc.</div>
</div><!-- fragment --><p><b>Create LoggerFactory which has different log levels for two groups</b> </p><div class="fragment"><div class="line">const factory = LFService.createNamedLoggerFactory(&quot;example&quot;, new LoggerFactoryOptions()</div>
<div class="line">  .addLogGroupRule(new LogGroupRule(new RegExp(&quot;model\\..+&quot;), LogLevel.INFO)))</div>
<div class="line">  .addLogGroupRule(new LogGroupRule(new RegExp(&quot;service\\..+&quot;), LogLevel.DEBUG)));</div>
<div class="line">const loggerModel = factory.getLogger(&quot;model.Person&quot;);  // This one will log on info and higher</div>
<div class="line">const loggerService = factory.getLogger(&quot;service.MyService&quot;);  // This one will log on debug and higher</div>
</div><!-- fragment --><p><b>Create LoggerFactory with different date format</b> </p><div class="fragment"><div class="line">// The loggerfactory uses a different dateformat, and different date separator.</div>
<div class="line">const loggerFactory = LFService.createNamedLoggerFactory(&quot;example&quot;, new LoggerFactoryOptions()</div>
<div class="line">  .addLogGroupRule(new LogGroupRule(new RegExp(&quot;.+&quot;),LogLevel.Info,</div>
<div class="line">    new LogFormat(new DateFormat(DateFormatEnum.YearDayMonthWithFullTime,&quot;/&quot;))));</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md4420"></a>
Api and documentation</h1>
<p>This describes the more often used part of the typescript API. Keep in mind the javascript API is exactly the same (except you need to call things the javascript way). Finally it's recommended to just look in the relevant classes as they contain the most up to date documentation.</p>
<p>The latest documentation also contains the classes below: Download <a href="https://github.com/mreuvers/typescript-logging/tree/master/downloads/bundle/latest">Documentation</a>.</p>
<h2><a class="anchor" id="autotoc_md4421"></a>
LFService</h2>
<p>Use this to create and configure a LoggerFactory. The LoggerFactory is used to get loggers from. </p><div class="fragment"><div class="line">/**</div>
<div class="line"> * Create a new LoggerFactory using given name (used for console api/extension).</div>
<div class="line"> * @param name Name Pick something short but distinguishable.</div>
<div class="line"> * @param options Options, optional</div>
<div class="line"> * @return {LoggerFactory}</div>
<div class="line"> */</div>
<div class="line">public static createNamedLoggerFactory(name: string, options: LoggerFactoryOptions | null = null): LoggerFactory;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Create a new LoggerFactory with given options (if any). If no options</div>
<div class="line"> * are specified, the LoggerFactory, will accept any named logger and will</div>
<div class="line"> * log on info level by default for, to the console.</div>
<div class="line"> * @param options Options, optional.</div>
<div class="line"> * @returns {LoggerFactory}</div>
<div class="line"> */</div>
<div class="line">public static createLoggerFactory(options: LoggerFactoryOptions | null = null): LoggerFactory;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4422"></a>
LoggerFactory</h2>
<p>Created by LFService. Than use getLogger(name: string) to get a new logger to log with.</p>
<h2><a class="anchor" id="autotoc_md4423"></a>
LogGroupRule</h2>
<p>This describes basically everything for the LoggerFactory you are creating. Create a new LogGroupRule...</p>
<div class="fragment"><div class="line">/**</div>
<div class="line"> * Create a LogGroupRule. Basically you define what logger name(s) match for this group, what level should be used what logger type (where to log)</div>
<div class="line"> * and what format to write in. If the loggerType is custom, then the callBackLogger must be supplied as callback function to return a custom logger.</div>
<div class="line"> * @param regExp Regular expression, what matches for your logger names for this group</div>
<div class="line"> * @param level LogLevel</div>
<div class="line"> * @param logFormat LogFormat</div>
<div class="line"> * @param loggerType Type of logger, if Custom, make sure to implement callBackLogger and pass in, this will be called so you can return your own logger.</div>
<div class="line"> * @param callBackLogger Callback function to return a new clean custom logger (yours!)</div>
<div class="line"> */</div>
<div class="line">constructor(regExp: RegExp, level: LogLevel, logFormat: LogFormat = new LogFormat(), loggerType: LoggerType = LoggerType.Console, callBackLogger?: (name: string, logGroupRule: LogGroupRule)=&gt;AbstractLogger)</div>
</div><!-- fragment --><p>The regular expression and logLevel are required, the first allows you to split your loggers in groups. For example a regex like: "model\\\\..+" would specify that loggers with names like: model.Person, model.Something, all would use this LogGroupRule (and thus have whatever was specified here applied).</p>
<p>The logLevel specifies the level of logging when it's turned 'on'. E.g, the default is LogLevel.Info.</p>
<h2><a class="anchor" id="autotoc_md4424"></a>
LogLevel</h2>
<p>Enumeration of...</p>
<div class="fragment"><div class="line">Trace,</div>
<div class="line">Debug,</div>
<div class="line">Info,</div>
<div class="line">Warn,</div>
<div class="line">Error,</div>
<div class="line">Fatal</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4425"></a>
LogFormat</h2>
<p>LogFormat allows to set some options about what a log line should look like. Create a new LogFormat...</p>
<div class="fragment"><div class="line">/**</div>
<div class="line"> * Constructor to create a LogFormat. Can be created without parameters where it will use sane defaults.</div>
<div class="line"> * @param dateFormat DateFormat (what needs the date look like in the log line)</div>
<div class="line"> * @param showTimeStamp Show date timestamp at all?</div>
<div class="line"> * @param showLoggerName Show the logger name?</div>
<div class="line"> */</div>
<div class="line">constructor(dateFormat: DateFormat = new DateFormat(), showTimeStamp: boolean = true, showLoggerName: boolean = true)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4426"></a>
DateFormat</h2>
<p>Defines what the timestamp should look like. Create a new DateFormat...</p>
<div class="fragment"><div class="line">/**</div>
<div class="line"> * Constructor, can be called empty as it uses defaults.</div>
<div class="line"> * @param formatEnum DateFormatEnum</div>
<div class="line"> * @param dateSeparator Separator used between dates</div>
<div class="line"> */</div>
<div class="line">constructor(formatEnum: DateFormatEnum = DateFormatEnum.Default, dateSeparator: string = &#39;-&#39;)</div>
</div><!-- fragment --><p>The DateFormatEnum allows some change on how the date is formatted.</p>
<h2><a class="anchor" id="autotoc_md4427"></a>
DateFormatEnum</h2>
<p>This is an enumeration with the following values:</p>
<div class="fragment"><div class="line">/**</div>
<div class="line"> * Displays as: year-month-day hour:minute:second,millis -&gt; 1999-02-12 23:59:59,123</div>
<div class="line"> * Note the date separator can be set separately.</div>
<div class="line"> */</div>
<div class="line">Default,</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Displays as: year-month-day hour:minute:second -&gt; 1999-02-12 23:59:59</div>
<div class="line"> * Note the date separator can be set separately.</div>
<div class="line"> */</div>
<div class="line">YearMonthDayTime,</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Displays as: year-day-month hour:minute:second,millis -&gt; 1999-12-02 23:59:59,123</div>
<div class="line"> * Note the date separator can be set separately.</div>
<div class="line"> */</div>
<div class="line">YearDayMonthWithFullTime,</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Displays as: year-day-month hour:minute:second -&gt; 1999-12-02 23:59:59</div>
<div class="line"> * Note the date separator can be set separately.</div>
<div class="line"> */</div>
<div class="line">YearDayMonthTime</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md4428"></a>
LogData</h1>
<div class="fragment"><div class="line">export interface LogData {</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * Message to log.</div>
<div class="line">   */</div>
<div class="line">  msg: string;</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * Optional additional data, by default JSON.stringify(..) is used to log it in addition to the message.</div>
<div class="line">   */</div>
<div class="line">  data?: any;</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * If present, and data is set - this lambda is used instead of JSON.stringify(..). Must return data as string.</div>
<div class="line">   * @param data Data to format</div>
<div class="line">   */</div>
<div class="line">  ds?(data: any): string;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md4429"></a>
Browser</h1>
<p>To use in the browser with javascript directly, download the (minified) library from <a href="https://github.com/mreuvers/typescript-logging/tree/master/downloads/bundle/latest">here</a>. The library is exposed by global variable TSL. See the example below.</p>
<div class="fragment"><div class="line">&lt;!DOCTYPE html&gt;</div>
<div class="line">&lt;html&gt;</div>
<div class="line">  &lt;head&gt;</div>
<div class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;typescript-logging-bundle.min.js&quot;&gt;&lt;/script&gt;</div>
<div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div>
<div class="line">      // Create default logger</div>
<div class="line">      var loggerFactory = TSL.LFService.createLoggerFactory();</div>
<div class="line">      // Get a logger called &quot;Hello&quot;</div>
<div class="line">      var logger = loggerFactory.getLogger(&quot;Hello&quot;);</div>
<div class="line"> </div>
<div class="line">      // Normal logging</div>
<div class="line">      logger.info(&quot;Hello this is a log statement.&quot;);</div>
<div class="line">      logger.error(&quot;Ooops&quot;, new Error(&quot;Failed!&quot;));</div>
<div class="line"> </div>
<div class="line">      // With callbacks, this is useful when log statements are expensive (e.g. require calculation)</div>
<div class="line">      // The callback is only called when needed.</div>
<div class="line">      logger.info(function() { return &quot;Only called when INFO (or lower) level is enabled!&quot;; });</div>
<div class="line">      logger.warn(function() { return &quot;Warn &quot; + somethingVeryExpensive(); }, function() { return new Error(&quot;Oh oh&quot;); });</div>
<div class="line">    &lt;/script&gt;</div>
<div class="line">  &lt;/head&gt;</div>
<div class="line">&lt;/html&gt;</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
